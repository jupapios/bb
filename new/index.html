<!doctype html>
<html>
<head>
	<meta name="viewport" content="width=600, height=1024, initial-scale=1">
		<title>caju</title>
		<link href='http://fonts.googleapis.com/css?family=Quicksand' rel='stylesheet'>
		<link href='css/normalize.css' rel='stylesheet'>
		<link href='css/main.css' rel='stylesheet'>
		<script>
				Element.prototype.hasClass = function(name) {
					return new RegExp("(?:^|\\s+)" + name + "(?:\\s+|$)").test(this.className);
				};
				Element.prototype.addClass = function(name) {
					if (!this.hasClass(name)) {
							this.className = this.className ? [this.className, name].join(' ') : name;
					}
				};
				Element.prototype.removeClass = function(name) {
					if (this.hasClass(name)) {
							var c = this.className;
							this.className = c.replace(new RegExp("(?:^|\\s+)" + name + "(?:\\s+|$)", "g"), "");
					}
				};
				window.$ = function () {
					return document.querySelector.apply(document, arguments)
				}
				window.$$ = function () {
					return document.querySelectorAll.apply(document, arguments)
				}
		</script>
		<script src="js/lib/socket.js"></script>
		<script src="js/lib/handlebars.js"></script>
		<script src="js/lib/box2d.js"></script>
		<script src="js/lib/easel.js"></script>
		<script>
		/*Handlebars.registerHelper('ifCond', function(v1, v2, options) {
		  if(v1 == v2) {
			return options.fn(this);
		  } else {
			return options.inverse(this);
		  }
		});*/
		</script>
</head>
<body class="caju">

		<div class="ball" style="top:20px;left:20px;"></div>

		<div class="main" role="main">
			<section class="caju">
				<h1>caju</h1>
			</section>
		</div>


		<script id="section-welcome" type="text/x-handlebars-template">
			<section>
				<div class="popup">
					<input type="text" placeholder="what's your name?">
					<a class="button" href="javascript:;">continue!</a>
				</div>
			</section>
		</script>

		<script id="section-intro" type="text/x-handlebars-template">
			<section>
				<span><img src="img/user4.png">{{user}}</span>
				<nav>
					<ul>
						<li>Play</li>
						<li>Join</li>
					</ul>
				</nav>
			</section>
		</script> 

		<script id="section-new" type="text/x-handlebars-template">
			<section>
				<span>{{user}}</span>
				<nav>
					<ul>
						<li>Play</li>
						<li>Join</li>
					</ul>
				</nav>
			</section>
		</script>

		<script id="section-join" type="text/x-handlebars-template">
			<section>
				<span><img src="img/user4.png">{{user}}</span>
				<div class="popup">
					<input type="text" placeholder="invitation">
					<a class="button" href="javascript:;">continue!</a>
				</div>
			</section>
		</script>

		<script id="section-waiting" type="text/x-handlebars-template">
			<section>
				<span><img src="img/user4.png">{{user}}</span>
				<div class="popup">
					<h2>{{id}}</h2>
					<a href="javascript:;">pin it</a>
					<a href="javascript:;">tweet it</a>
					<a href="javascript:;">face it</a>
				</div>
			</section>
		</script>

		<!-- NOT SURE IF CHOOSE A CHARACTER PER GAME OR ONE PER PLAYER
		<script id="section-choose" type="text/x-handlebars-template">
			<section>
				<span>{{user}}</span>
				{{#ifCond player 1}}
					<img class="active" src="">
					<img src="">
				{{else}}
					<img src="">
					<img class="active" src="">
				{{/ifCond}}
			</section>
		</script>		
		-->

		<script id="section-game" type="text/x-handlebars-template">
			<section>
				<div class="alert popup">
					<p>your friend ran!</p>
				</div>
				<div class="user-stats enemy"><span>0</span><span>{{player}}</span></div>
				<div class="user-stats player"><span>0</span><span>{{player}}</span></div>
				<canvas></canvas>
				<!--<img class="player_bear" src="img/player_01.png">
				<img class="player_bunny" src="img/player_02.png">-->
			</section>
		</script>

		<script>
			
			const DEBUG = false;
			const socket_url = "http://192.168.1.21:5000";

			/************************************
			 * Game
			 ************************************/

			var time_1 = DEBUG ? 0: 1400;
			var time_2 = DEBUG ? 0: 800;

			var container = $('.main');
			var source;
			var template;
			var init;
			var instance;
			var stage;

			var player_01 = new Image();
			var player_02 = new Image();

			// Data from localStorage
			var caju_user = localStorage.getItem("caju_name");

			// Templates
			var template_join = Handlebars.compile($("#section-join").innerHTML);
			var template_new = Handlebars.compile($("#section-new").innerHTML);
			var template_waiting = Handlebars.compile($("#section-waiting").innerHTML);
			//var template_choose = Handlebars.compile($("#section-choose").innerHTML);
			var template_game = Handlebars.compile($("#section-game").innerHTML);


			window.del = function (element, callback) {
				//var element = $(selector);
				element.addClass("hide");
				setTimeout(function () {
					element.innerHTML = '';
					element.removeClass("hide");
					callback();
				}, time_2);
			}

			var mouseTarget;	// the display object currently under the mouse, or being dragged
			var dragStarted;	// indicates whether we are currently in a drag operation
			var offset;
			var update = true;			


			function handleImageLoad(event) {
				//console.log(event);
				var image = event.target;
				//var bitmap;
				var container = new Container();
				stage.addChild(container);

				// create and populate the screen with random daisies:
				this.bitmap = new Bitmap(image);
				container.addChild(this.bitmap);

				for(var option in this.options) {
			        this.bitmap[option] = this.options[option];
			    }
			    //console.log(bitmap)
				/*bitmap.x = 300;
				bitmap.y = -60;
				bitmap.rotation = 0;*/
				this.bitmap.regX = this.bitmap.image.width/2|0;
				this.bitmap.regY = this.bitmap.image.height/2|0;
				//bitmap.scaleX = bitmap.scaleY = bitmap.scale = 1;
				//bitmap.name = "bmp_1";

				// wrapper function to provide scope for the event handlers:
				if(this.name == other_player) {
					(function(target) {
						target.onPress = function(evt) {
							// bump the target in front of it's siblings:
							container.addChild(target);
							var offset = {x:target.x-evt.stageX, y:target.y-evt.stageY};

							// add a handler to the event object's onMouseMove callback
							// this will be active until the user releases the mouse button:
							evt.onMouseMove = function(ev) {
								var x = ev.stageX+offset.x;
								var y = ev.stageY+offset.y;
								
								if((other_player === 1 && y > 864) || (other_player === 0 && y < 160)) {
									target.x = x;
									target.y = y;
									socket.emit('move', {
						                data: {
						                    x: x,
						                    y: y
						                }
						            });			
									// indicate that the stage should be updated on the next tick:
									update = true;
								}							
							}
						}
						target.onMouseOver = function() {
							//target.scaleX = target.scaleY = target.scale*1.2;
							update = true;
						}
						target.onMouseOut = function() {
							//target.scaleX = target.scaleY = target.scale;
							update = true;
						}
					})(this.bitmap);
				}

				Ticker.addListener(window);
			}

			function tick() {
				// this set makes it so the stage only re-renders when an event handler indicates a change has happened.
				if (update) {
					update = false; // only update once
					stage.update();
				}
			}				

			// GAME DEFINITION
			var game = {

				//BUTTON FUNCTIONS
				play: function () {
					console.log('play');
					if(typeof blackberry == "undefined") {
						//webrtc
						if(DEBUG) console.log("TODO: webrtc");
					} else {
						blackberry.launch.launchCamera();
					}
					if(DEBUG) console.log('Click: new');
					if(connection_ready) {
						socket.emit('new', caju_user);
						other_player = 1
					}					
				},
				join: function () {
					del(container, function () {
						container.innerHTML = template_join({user:caju_user});
						document.body.className = "join";

						var anchor = container.querySelector('a');

						function join_game () {
							var instanceId = this.parentElement.querySelector("input").value;
							if(instanceId) {
								socket.emit('join', {instanceId:instanceId, player:caju_user});

								instance = instanceId;
								other_player = 0;
							} else {
								var self = this;
								self.parentElement.addClass("error");
								setTimeout(function () {
									self.parentElement.removeClass("error");
								}, 700);
							}
						}
						
							anchor.addEventListener('click', join_game);
							anchor.addEventListener('touch', join_game);

					});
				},
				save: function () {
					var input_value = this.parentElement.querySelector("input").value;
					if(input_value) {
						caju_user = input_value;
						localStorage.setItem("caju_name", caju_user);
						init();
					} else {
						var self = this;
						self.parentElement.addClass("error");
						setTimeout(function () {
							self.parentElement.removeClass("error");
						}, 700);
					}
				},

				// GAME FUNCTIONS
				wait: function (id) {
					del(container, function () {
						container.innerHTML = template_waiting({user:caju_user, id:id});
						document.body.className = "waiting";
					});
				},

				start: function (enemy) {
					//container.innerHTML = template_game({player:caju_user});
					container.innerHTML = template_game({player:caju_user, enemy:enemy});
					document.body.className = "game";
					document.body.removeChild($('.ball'));

					//Canvas work
					var canvas = $('canvas');
					var context = canvas.getContext("2d");

					var context01 = canvas.getContext("2d");
					var context02 = canvas.getContext("2d");

					canvas.width = 600;
					canvas.height = 1024;

					stage = new Stage(canvas);


					// box2d objects
					var
						  b2Vec2 = Box2D.Common.Math.b2Vec2
						, b2AABB = Box2D.Collision.b2AABB
						, b2BodyDef = Box2D.Dynamics.b2BodyDef
						, b2Body = Box2D.Dynamics.b2Body
						, b2FixtureDef = Box2D.Dynamics.b2FixtureDef
						, b2Fixture = Box2D.Dynamics.b2Fixture
						, b2World = Box2D.Dynamics.b2World
						, b2MassData = Box2D.Collision.Shapes.b2MassData
						, b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
						, b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
						, b2DebugDraw = Box2D.Dynamics.b2DebugDraw
						, b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
					;

					var world = new b2World(
						new b2Vec2(0,0) // gravity
						, true          // sleep
					);

					var bodyDef = new b2BodyDef;
					bodyDef.type = b2Body.b2_dynamicBody; //define object type
					bodyDef.position.Set(2, 2);           //define position

					var fixDef = new b2FixtureDef;
					fixDef.density = 10.0;                //define density
					fixDef.friction = 0.5;                //define friction
					fixDef.restitution =0.2;              //define restitution
					 
					fixDef.shape = new b2PolygonShape;    //define shape
					fixDef.shape.SetAsBox(1, 1);          //define size

					world.CreateBody(bodyDef).CreateFixture(fixDef);


					var bodyDef = new b2BodyDef;
					bodyDef.type = b2Body.b2_dynamicBody; //define object type
					bodyDef.position.Set(4, 6);           //define position

					var fixDef = new b2FixtureDef;
					fixDef.density = 10.0;                //define density
					fixDef.friction = 0.5;                //define friction
					fixDef.restitution =0.2;              //define restitution
					 
					fixDef.shape = new b2PolygonShape;    //define shape
					fixDef.shape.SetAsBox(1, 1);          //define size

					world.CreateBody(bodyDef).CreateFixture(fixDef);					


					/**** BEGIN TEST *******/
					//setup debug draw
		         	/*var debugDraw = new b2DebugDraw();
					debugDraw.SetSprite(context);
					debugDraw.SetDrawScale(30.0);
					debugDraw.SetFillAlpha(0.5);
					debugDraw.SetLineThickness(1.0);
					debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
					world.SetDebugDraw(debugDraw);

					function update() {
						world.Step(1 / 60, 10, 10);
						world.DrawDebugData();
						world.ClearForces();
					};

					//window.setInterval(update, 1000 / 60);*/
					/**** END TEST *******/

					/*player_01.src = "img/player_01.png"
					player_02.src = "img/player_02.png"

					player_01.options = {
						  x: 360
						, y: 1250
						, rotation: 180					
					}


					player_02.options = {
						  x: 233
						, y: -210
						, rotation: 0
					}					


					var TOTALIMAGES = 2;
					var imagesLoaded = 0;

					player_01.onload = drawPlayers;
					player_02.onload = drawPlayers;

					console.log(other_player);

					var player;


					//player_02.addEventListener("load", drawPlayers);

					

					function drawPlayers() {
						imagesLoaded++;
						console.log("TO DRAW")

				        this.bmp = new Bitmap(this);

				        for(var option in this.options) {
				        	this.bmp[option] = this.options[option];
				        }
				        console.log(this.bmp);
				        this.bmp.regX = this.bmp.image.width/2|0;
						this.bmp.regY = this.bmp.image.height/2|0;

						stage.addChild(this.bmp);

						//function mouseMove

						if(imagesLoaded === TOTALIMAGES) {
							if(other_player === 1) {
								console.log('IM LE ONE');
								// easeljs' onClick
								player_01.bmp.onPress = movePlayer;
							} else {
								player_02.bmp.onPress= movePlayer;
							}
					        stage.update();
						}
					}

					function movePlayer (e) {
						var initialX = e.stageX;
						var initialY = e.stageY;
						var self = this;
						e.onMouseMove = function (e) {
							var x = e.stageX;
							var y = e.stageY;
							console.log(e);
							self.x = x;
							self.y = y;
							stage.update();
							// maybe at player.onTick
							socket.emit('move', {
				                data: {
				                    x: self.x,
				                    y: self.y
				                }
				            });		
						}
					}	*/


					// enable touch interactions if supported on the current device:
					Touch.enable(stage);

					// enabled mouse over / out events
					stage.enableMouseOver(10);
					stage.mouseMoveOutside = true; // keep tracking the mouse even when it leaves the canvas

					// load the source image:
					player_01.src = "img/player_01.png";
					player_01.options = {
						  x: 310
						, y: 1100
						, rotation: 180
					}
					player_01.onload = handleImageLoad;
					player_01.name = 1;

					player_02.options = {
						  x: 280
						, y: -80
						, rotation: 0
					}
					player_02.src = "img/player_02.png";
					player_02.onload = handleImageLoad;
					player_02.name = 0;




					/***********************
						COPY FROM DEMO.HTML
					************************/
				  /*function init_canvas() {
					 var   b2Vec2 = Box2D.Common.Math.b2Vec2
						,  b2AABB = Box2D.Collision.b2AABB
						,	b2BodyDef = Box2D.Dynamics.b2BodyDef
						,	b2Body = Box2D.Dynamics.b2Body
						,	b2FixtureDef = Box2D.Dynamics.b2FixtureDef
						,	b2Fixture = Box2D.Dynamics.b2Fixture
						,	b2World = Box2D.Dynamics.b2World
						,	b2MassData = Box2D.Collision.Shapes.b2MassData
						,	b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
						,	b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
						,	b2DebugDraw = Box2D.Dynamics.b2DebugDraw
						,  b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
						;
					 
					 var world = new b2World(
						   new b2Vec2(0, 0)    //gravity
						,  true                 //allow sleep
					 );
					 
					 var fixDef = new b2FixtureDef;
					 fixDef.density = 1.0;
					 fixDef.friction = 0.5;
					 fixDef.restitution = 0.2;
					 
					 var bodyDef = new b2BodyDef;
					 
					 //create ground
					 bodyDef.type = b2Body.b2_staticBody;
					 fixDef.shape = new b2PolygonShape;
					 fixDef.shape.SetAsBox(20, 2);
					 bodyDef.position.Set(10, 400 / 30 + 1.8);
					 world.CreateBody(bodyDef).CreateFixture(fixDef);
					 bodyDef.position.Set(10, -1.8);
					 world.CreateBody(bodyDef).CreateFixture(fixDef);
					 fixDef.shape.SetAsBox(2, 14);
					 bodyDef.position.Set(-1.8, 13);
					 world.CreateBody(bodyDef).CreateFixture(fixDef);
					 bodyDef.position.Set(21.8, 13);
					 world.CreateBody(bodyDef).CreateFixture(fixDef);
					 
					 
					 //create some objects
					 bodyDef.type = b2Body.b2_dynamicBody;
					 for(var i = 0; i < 10; ++i) {
						if(Math.random() > 0.5) {
						   fixDef.shape = new b2PolygonShape;
						   fixDef.shape.SetAsBox(
								 Math.random() + 0.1 //half width
							  ,  Math.random() + 0.1 //half height
						   );
						} else {
						   fixDef.shape = new b2CircleShape(
							  Math.random() + 0.1 //radius
						   );
						}
						bodyDef.position.x = Math.random() * 10;
						bodyDef.position.y = Math.random() * 10;
						world.CreateBody(bodyDef).CreateFixture(fixDef);
					 }
					 
					 //setup debug draw
					 var debugDraw = new b2DebugDraw();
						debugDraw.SetSprite(context);
						debugDraw.SetDrawScale(30.0);
						debugDraw.SetFillAlpha(0.5);
						debugDraw.SetLineThickness(1.0);
						debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
						world.SetDebugDraw(debugDraw);
					 
					 window.setInterval(update, 1000 / 60);
					 
					 //mouse
					 
					 var mouseX, mouseY, mousePVec, isMouseDown, selectedBody, mouseJoint;
					 var canvasPosition = getElementPosition(canvas);
					 
					 document.addEventListener("mousedown", function(e) {
						isMouseDown = true;
						handleMouseMove(e);
						document.addEventListener("mousemove", handleMouseMove, true);
					 }, true);

					 document.addEventListener("touchstart", function(e) {
						isMouseDown = true;
						handleMouseMove(e);
						document.addEventListener("touchmove", handleMouseMove, true);
					 }, true);
					 
					 document.addEventListener("mouseup", function() {
						document.removeEventListener("mousemove", handleMouseMove, true);
						isMouseDown = false;
						mouseX = undefined;
						mouseY = undefined;
					 }, true);

					 document.addEventListener("touchend", function() {
						document.removeEventListener("touchmove", handleMouseMove, true);
						isMouseDown = false;
						mouseX = undefined;
						mouseY = undefined;
					 }, true);
					 
					 function handleMouseMove(e) {
						mouseX = (e.clientX - canvasPosition.x) / 30;
						mouseY = (e.clientY - canvasPosition.y) / 30;
					 };
					 
					 function getBodyAtMouse() {
						mousePVec = new b2Vec2(mouseX, mouseY);
						var aabb = new b2AABB();
						aabb.lowerBound.Set(mouseX - 0.001, mouseY - 0.001);
						aabb.upperBound.Set(mouseX + 0.001, mouseY + 0.001);
						
						// Query the world for overlapping shapes.

						selectedBody = null;
						world.QueryAABB(getBodyCB, aabb);
						return selectedBody;
					 }

					 function getBodyCB(fixture) {
						if(fixture.GetBody().GetType() != b2Body.b2_staticBody) {
						   if(fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
							  selectedBody = fixture.GetBody();
							  return false;
						   }
						}
						return true;
					 }
					 
					 //update
					 
					 function update() {
					 
						if(isMouseDown && (!mouseJoint)) {
						   var body = getBodyAtMouse();
						   if(body) {
							  var md = new b2MouseJointDef();
							  md.bodyA = world.GetGroundBody();
							  md.bodyB = body;
							  md.target.Set(mouseX, mouseY);
							  md.collideConnected = true;
							  md.maxForce = 300.0 * body.GetMass();
							  mouseJoint = world.CreateJoint(md);
							  body.SetAwake(true);
						   }
						}
						
						if(mouseJoint) {
						   if(isMouseDown) {
							  mouseJoint.SetTarget(new b2Vec2(mouseX, mouseY));
						   } else {
							  world.DestroyJoint(mouseJoint);
							  mouseJoint = null;
						   }
						}
					 
						world.Step(1 / 60, 10, 10);
						world.DrawDebugData();
						world.ClearForces();
					 };
					 
					 //helpers
					 
					 //http://js-tut.aardon.de/js-tut/tutorial/position.html
					 function getElementPosition(element) {
						var elem=element, tagname="", x=0, y=0;
					   
						while((typeof(elem) == "object") && (typeof(elem.tagName) != "undefined")) {
						   y += elem.offsetTop;
						   x += elem.offsetLeft;
						   tagname = elem.tagName.toUpperCase();

						   if(tagname == "BODY")
							  elem=0;

						   if(typeof(elem) == "object") {
							  if(typeof(elem.offsetParent) == "object")
								 elem = elem.offsetParent;
						   }
						}

						return {x: x, y: y};
					 }


				  };

				  init_canvas();  				
					*/



				}
			}


			init = function() {
				if(caju_user) {
					source  = $("#section-intro").innerHTML;
				} else {
					source  = $("#section-welcome").innerHTML;
				}

				template = Handlebars.compile(source);

				setTimeout(function () {
					del(container, function () {

						if(caju_user) { // rendering intro section
							container.innerHTML = template({user:caju_user});

							var li = container.querySelectorAll('li');

								li[0].addEventListener('click', game.play);
								li[1].addEventListener('click', game.join);
								li[0].addEventListener('touch', game.play);
								li[1].addEventListener('touch', game.join);
							document.body.className = "intro";
						} else { //rendering welcome section
							container.innerHTML = template();

							if(DEBUG) {
								game.start();
							} else {
								var anchor = container.querySelector('a');

									anchor.addEventListener('click', game.save);
									anchor.addEventListener('touch', game.save);
								document.body.className = "welcome";
							}
						}
					});
				}, time_1);
			};

			/************************************
			 * Ball
			 ************************************/

			var ball = $(".ball");
			var moving = false;
			var initial_x, initial_y;

			function move_ball (e) {

				e.preventDefault();

				var x = e.x || e.offsetX || (e.pageX - ball.offsetLeft);
				var y = e.y || e.offsetY || (e.pageY - ball.offsetTop);
				if(moving) {
					if(y > 0 && y < (window.innerHeight - 40)) {
						ball.style.top = parseInt(ball.style.top) + (y-initial_y) +"px";	
					}
					if(x > 0 && x < (window.innerWidth - 40)) {
						ball.style.left = parseInt(ball.style.left) + (x-initial_x) +"px";	
					}
					initial_x = x;
					initial_y = y;
				}
			}
			window.addEventListener("mousemove", move_ball, false);
			//window.addEventListener("touchmove", move_ball, false);

			window.addEventListener("mouseup", function () {
				document.body.removeClass("no-select");
				moving = false;
			}, false);

			window.addEventListener("touchend", function () {
				document.body.removeClass("no-select");
				moving = false;
			}, false);

			ball.addEventListener("mousedown", function (e) {
				initial_x = e.x || e.offsetX || (e.pageX - ball.offsetLeft);
				initial_y = e.y || e.offsetY || (e.pageY - ball.offsetTop);
				document.body.addClass("no-select");
				moving = true;
			}, false);

			ball.addEventListener("touchstart", function (e) {
				initial_x = e.x || e.offsetX || (e.pageX - ball.offsetLeft);
				initial_y = e.y || e.offsetY || (e.pageY - ball.offsetTop);;
				document.body.addClass("no-select");
				moving = true;
			}, false);			


			window.addEventListener("devicemotion", function(event) {
				if(window.orientation == 0) {
					var x = parseInt(ball.style.left) + event.accelerationIncludingGravity.x;
					var y = parseInt(ball.style.top) - event.accelerationIncludingGravity.y;

					if(x > 0 && x < (window.innerWidth - 40)) ball.style.left =  x + 'px'; 
					if(y > 0 && y < (window.innerHeight - 40)) ball.style.top = y + 'px';            		
				} else if(window.orientation == 90) {
					var x = parseInt(ball.style.top) - event.accelerationIncludingGravity.x;
					var y = parseInt(ball.style.left) - event.accelerationIncludingGravity.y;

					if(x < window.innerHeight && x > 0) ball.style.top =  x + 'px'; 
					if(y < window.innerWidth && y > 0) ball.style.left = y + 'px'; 
				} else if(window.orientation == -90) {
					var x = parseInt(ball.style.top) + event.accelerationIncludingGravity.x;
					var y = parseInt(ball.style.left) + event.accelerationIncludingGravity.y;

					if(x < window.innerHeight && x > 0) ball.style.top =  x + 'px'; 
					if(y < window.innerWidth && y > 0) ball.style.left = y + 'px'; 
				}
			}, true); 



			/************************************
			 * Socket
			 ************************************/

			var connection_ready = false;

			if(typeof io !== "undefined") {

				socket = io.connect(socket_url, {
					'reconnect': true
					, 'reconnection delay': 500
					, 'max reconnection attempts': 5
				});

				socket.on('connect', function () {
					connection_ready = true;
					init();
					if(DEBUG) console.log('OPEN');
				});

				socket.on('join', function (data) {
					other_player = 0;
					if(data) {
						//do something
					} else {
						var div = $('.main div');
						div.addClass("error");
						setTimeout(function () {
							div.removeClass("error");
						}, 700);
					}
				});

				socket.on('new', function (data) {
					//console.log(data);
					game.wait(data.id);
				});

				socket.on('move', function (data) {
					if(other_player === 1) {
						player_02.bitmap.x = data.x;
						player_02.bitmap.y = data.y;
					} else {
						player_01.bitmap.x = data.x;
						player_01.bitmap.y = data.y;
					}
					update = true;
				});

				socket.on('bye', function (data) {
					container.addClass("no-active");
				});				

				socket.on('ready', function (enemy) {
					del(container, function () {
						game.start(enemy);
					});
					/*del(container, function () {
						container.innerHTML = template_choose({user:caju_user, player:other_player});
						document.body.className = "choose";
					});*/
				});
			}

		</script>
</body>
</html>